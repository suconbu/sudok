<!DOCTYPE html>
<html lang="ja">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="css/sanitize.css">
<link rel="stylesheet" href="css/typography.css">
<link rel="stylesheet" href="css/style.css">
<script src="js/vue.js"></script>
<script>
  // Adjust page height for mobile Chrome
  let vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
  window.addEventListener('resize', () => {
    vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  });
</script>

<title>sudok</title>

<div id="app" v-cloak>
  <main>
    <h1 class="title">
      sudok
    </h1>
    <div class="masu3x3 masu-frame">
      <div class="masu3x3 masu-block" v-for="block in blocks">
        <!-- マス -->
        <div class="masu3x3 masu-cell" v-for="cell in block"
          v-bind:class="{
            'color-reached': cell.reached,
            'color-selected': cell.id == selectedCellId
          }"
          :id="`cell-${cell.id}`"
          @click="cellClick(cell)">
          <!-- マスの中の数字 -->
          <div class="masu-cell-number center-middle">
            {{cell.value}}
          </div>
          <!-- 候補表示用3x3マス -->
          <div class="masu3x3 masu-cell-koho center-middle"
            v-for="(_, idx) in Array(9).fill()"
            v-bind:class="{
              'color-koho': cell.koho.has(idx+1),
              'hidden': cell.koho.size == 9
            }">
            {{cell.koho.has(idx+1) ? idx+1 : null}}
          </div>
        </div>
      </div>
    </div>
  </main>
</div>

<script>
  const app = new Vue({
    el: "#app",
    data: {
      cells: [],
      blocks: [],
      numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9],
      selectedCellId: null
    },
    created() {
      this.cells = Array(9 * 9).fill().map((_, idx) => {
        return {
          id: idx,
          value: null,
          koho: new Set(this.numbers),
          reached: false
        };
      });
      this.blocks = new Array(9).fill().map((_) => { return [] });
      this.cells.forEach((cell, idx) => {
        // +----------------------------+
        // | 0| 1| 2|| 3| 4| 5|| 6| 7| 8|
        // +----------------------------+
        // | 9|10|11||  |  |  ||  |  |  |
        // +----------------------------+
        this.blocks[Math.floor(idx / 3) % 3 + Math.floor(idx / (9 * 3)) * 3].push(cell);
      });
    },
    mounted() {
      document.addEventListener("keydown", this.keydown);
    },
    methods: {
      cellClick(cell) {
        if (cell.koho.size == 1) {
          cell.value = cell.koho.values().next().value;
          cell.koho.clear();
          cell.reached = false;
        }

        if (this.selectedCellId === cell.id) {
          this.selectedCellId = null;
        } else {
          this.selectedCellId = cell.id;
        }
      },
      keydown(e) {
        const cell = (this.selectedCellId !== null) ? this.cells[this.selectedCellId] : null;
        if (cell && "1" <= e.key && e.key <= "9") {
          const n = parseInt(e.key);
          if (cell.value) {
            if (inspectCells(this.cells, cell.id, n)) {
              cell.value = n;
              updateKoho(this.cells);
            } else {
              this.flashSelection();
            }
          } else {
            if (cell.koho.has(n)) {
              cell.value = n;
              updateKoho(this.cells);
            } else {
              this.flashSelection();
            }
          }
        } else if (e.key.startsWith("Arrow")) {
          if (this.selectedCellId !== null) {
            if (e.key == "ArrowLeft") {
              this.selectedCellId += (this.selectedCellId % 9 == 0) ? +8 : -1;
            } else if (e.key == "ArrowRight") {
              this.selectedCellId += (this.selectedCellId % 9 == 8) ? -8 : +1;
            } else if (e.key == "ArrowUp") {
              this.selectedCellId += (Math.floor(this.selectedCellId / 9) == 0) ? +(8 * 9) : -9;
            } else if (e.key == "ArrowDown") {
              this.selectedCellId += (Math.floor(this.selectedCellId / 9) == 8) ? -(8 * 9) : +9;
            } else {
            }
          } else {
            this.selectedCellId = 40;
          }
        } else if (cell && e.key == "Delete") {
          cell.value = null;
          updateKoho(this.cells);
        } else {
        }
      },
      flashSelection() {
        const id = this.selectedCellId;
        this.selectedCellId = null;
        setTimeout(() => this.selectedCellId = id, 100);
      }
    }
  });

  function xyToIndex(x, y) {
    return (y * 9) + x;
  }

  function indexToX(idx) {
    return idx % 9;
  }

  function indexToY(idx) {
    return Math.floor(idx / 9);
  }

  function indexToBlock(idx) {
    const bx = Math.floor(idx / 3) % 3;
    const by = Math.floor(idx / (9 * 3));
    return (by * 3) + bx;
  }

  function blockToIndex(blockIndex, cellIndex) {
    const x = ((blockIndex % 3) * 3) + (cellIndex % 3);
    const y = Math.floor(blockIndex / 3) * 3  + Math.floor(cellIndex / 3) % 3;
    return (y * 9) + x;
  }

  // 全セルの候補を更新
  function updateKoho(cells) {
    // 候補更新
    for (let y = 0; y < 9; ++y) {
      for (let x = 0; x < 9; ++x) {
        const cell = cells[xyToIndex(x, y)];
        cell.koho = getKohoSet(cells, cell.id);
        cell.reached = (cell.koho.size == 1);
      }
    }
  }

  // 指定したセルの候補を取得
  function getKohoSet(cells, cellIndex) {
    const koho = [];
    const cell = cells[cellIndex];
    if (!cell.value) {
      for (let n = 1; n <= 9; ++n) {
        if (inspectCells(cells, cell.id, n)) {
          koho.push(n);
        }
      }
    }
    return new Set(koho);
  }

  // 仮に指定の値を入れた場合に
  // すべての行・列・ブロックに重複がいないか確認
  // true:重複なし false:あり
  function inspectCells(cells, cellIndex, tryValue) {
    const oldValue = cells[cellIndex].value;
    cells[cellIndex].value = tryValue;
    let result = true;
    const col = indexToX(cellIndex);
    const row = indexToY(cellIndex);
    const block = indexToBlock(cellIndex);
    if (
      !inspectRow(cells, row) ||
      !inspectCol(cells, col) ||
      !inspectBlock(cells, block)
    ) {
      result = false;
    }
    cells[cellIndex].value = oldValue;
    return result;
  }

  function inspectRow(cells, rowIndex) {
    return !hasDuplicate(Array(9).fill().map((_, i) => cells[xyToIndex(i, rowIndex)].value));
  }

  function inspectCol(cells, colIndex) {
    return !hasDuplicate(Array(9).fill().map((_, i) => cells[xyToIndex(colIndex, i)].value));
  }

  function inspectBlock(cells, blockIndex) {
    return !hasDuplicate(Array(9).fill().map((_, i) => cells[blockToIndex(blockIndex, i)].value));
  }

  function hasDuplicate(values) {
    const a = values.filter(v => v);
    const s = new Set(a);
    return s.size != a.length;
  }
</script>
</html>
