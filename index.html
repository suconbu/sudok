<!DOCTYPE html>
<html lang="ja">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="css/sanitize.css">
<link rel="stylesheet" href="css/typography.css">
<link rel="stylesheet" href="css/style.css">
<script src="js/vue.js"></script>
<script>
  // Adjust page height for mobile Chrome
  let vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
  window.addEventListener('resize', () => {
    vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  });
</script>

<title>sudok</title>

<div id="app" v-cloak>
  <main>
    <h1 class="title">
      sudok
    </h1>
    <div class="masu3x3 masu-frame">
      <div class="masu3x3 masu-block" v-for="block in blocks">
        <!-- マス -->
        <div class="masu3x3 masu-cell" v-for="cell in block"
          v-bind:class="{
            'color-lastone': cell.koho.size == 1,
            'color-selected': cell.id == selectedCellId
          }"
          :id="`cell-${cell.id}`"
          @click="cellClick(cell)">
          <!-- マスの中の数字 -->
          <div class="masu-cell-number center-middle">
            {{cell.value}}
          </div>
          <!-- 候補表示用3x3マス -->
          <div class="masu3x3 masu-cell-koho center-middle"
            v-for="(_, idx) in Array(9).fill()"
            v-bind:class="{
              'color-koho': cell.koho.has(idx+1),
              'hidden': cell.koho.size == 9
            }">
            {{cell.koho.has(idx+1) ? idx+1 : null}}
          </div>
        </div>
      </div>
    </div>
  </main>
</div>

<script>
  const app = new Vue({
    el: "#app",
    data: {
      cells: [],
      blocks: [],
      selectedCellId: null
    },
    created() {
      this.cells = Array(9 * 9).fill().map((_, idx) => {
        return {
          id: idx,
          x: idx % 9,
          y: Math.floor(idx / 9),
          value: null,
          koho: new Set()
        };
      });
      this.blocks = new Array(9).fill().map((_) => { return [] });
      this.cells.forEach((cell, idx) => {
        // +----------------------------+
        // | 0| 1| 2|| 3| 4| 5|| 6| 7| 8|
        // +----------------------------+
        // | 9|10|11||  |  |  ||  |  |  |
        // +----------------------------+
        this.blocks[Math.floor(idx / 3) % 3 + Math.floor(idx / (9 * 3)) * 3].push(cell);
      });
      updateKoho(this.cells);
    },
    mounted() {
      // const centerCell = document.querySelector("#cell-44");
      // centerCell.focus(true);
      document.addEventListener("keydown", this.keydown);
    },
    methods: {
      cellClick(cell) {
        if (cell.koho.size == 1) {
          cell.value = cell.koho.values().next().value;
          cell.koho.clear();
        }

        if (this.selectedCellId === cell.id) {
          this.selectedCellId = null;
        } else {
          this.selectedCellId = cell.id;
        }
      },
      keydown(e) {
        const cell = (this.selectedCellId !== null) ? this.cells[this.selectedCellId] : null;
        if (cell && "1" <= e.key && e.key <= "9") {
          const n = parseInt(e.key);
          if (cell.value) {
            const old = cell.value;
            cell.value = n;
            if (!validateCells(this.cells)) {
              cell.value = old;
              this.flashSelection();
            }
          } else {
            if (cell.koho.has(n)) {
              cell.value = n;
            } else {
              this.flashSelection();
            }
          }
        } else if (e.key.startsWith("Arrow")) {
          if (this.selectedCellId !== null) {
            if (e.key == "ArrowLeft") {
              this.selectedCellId += (this.selectedCellId % 9 == 0) ? +8 : -1;
            } else if (e.key == "ArrowRight") {
              this.selectedCellId += (this.selectedCellId % 9 == 8) ? -8 : +1;
            } else if (e.key == "ArrowUp") {
              this.selectedCellId += (Math.floor(this.selectedCellId / 9) == 0) ? +(8 * 9) : -9;
            } else if (e.key == "ArrowDown") {
              this.selectedCellId += (Math.floor(this.selectedCellId / 9) == 8) ? -(8 * 9) : +9;
            } else {
            }
          } else {
            this.selectedCellId = 40;
          }
        } else if (cell && e.key == "Delete") {
          cell.value = null;
        } else {
        }
        updateKoho(this.cells);
      },
      flashSelection() {
        const id = this.selectedCellId;
        this.selectedCellId = null;
        setTimeout(() => this.selectedCellId = id, 100);
      }
    }
  });

  function xyToIndex(x, y) {
    return (y * 9) + x;
  }

  function blockToIndex(blockIndex, cellIndex) {
    const x = Math.floor(blockIndex / 3) * 3  + Math.floor(cellIndex / 3) % 3;
    const y = ((blockIndex % 3) * 3) + (cellIndex % 3);
    return (y * 9) + x;
  }

  // 全セルの候補を更新
  function updateKoho(cells) {
    for (let y = 0; y < 9; ++y) {
      for (let x = 0; x < 9; ++x) {
        cells[xyToIndex(x, y)].koho = getKohoSet(cells, x, y);
      }
    }
  }

  // 指定したセルの候補を取得
  function getKohoSet(cells, x, y) {
    const koho = [];
    for (let n = 1; n <= 9; ++n) {
      const cell = cells[xyToIndex(x, y)];
      let valid = false;
      if (!cell.value) {
        cell.value = n;
        if (validateCells(cells)) {
          koho.push(n);
        }
        cell.value = null;
      }
    }
    return new Set(koho);
  }

  // すべての行・列・ブロックに重複がいないか確認
  // true:重複なし false:あり
  function validateCells(cells) {
    for (let i = 0; i < 9; ++i) {
      if (
        !validateRow(cells, i) ||
        !validateCol(cells, i) ||
        !validateBlock(cells, i)
      ) {
        return false;
      }
    }
    return true;
  }

  function validateRow(cells, rowIndex) {
    return !hasDuplicate(Array(9).fill().map((_, i) => cells[xyToIndex(rowIndex, i)].value));
  }

  function validateCol(cells, colIndex) {
    return !hasDuplicate(Array(9).fill().map((_, i) => cells[xyToIndex(i, colIndex)].value));
  }

  function validateBlock(cells, blockIndex) {
    return !hasDuplicate(Array(9).fill().map((_, i) => cells[blockToIndex(blockIndex, i)].value));
  }

  function hasDuplicate(values) {
    const a = values.filter(v => v);
    const s = new Set(a);
    return s.size != a.length;
  }
</script>
</html>
