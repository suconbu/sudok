<!DOCTYPE html>
<html lang="ja">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="css/sanitize.css">
<link rel="stylesheet" href="css/typography.css">
<link rel="stylesheet" href="css/style.css">
<script src="js/vue.js"></script>
<script>
  // Adjust page height for mobile Chrome
  let vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
  window.addEventListener('resize', () => {
    vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  });
</script>

<title>sudok</title>

<div id="app" v-cloak>
  <main>
    <h1 class="title">
      sudok
    </h1>
    <div class="masu3x3 masu-frame">
      <div class="masu3x3 masu-block" v-for="block in blocks">
        <!-- „Éû„Çπ -->
        <div class="masu3x3 masu-cell" v-for="cell in block"
          v-bind:class="{
            'color-reached-cell': cell.reachedNo != 0 && (cell.koho.size == 1 || reachedKohoVisible),
            'color-hint-no': hintNo != null && cell.value == hintNo,
            'color-hint-cell': hintNo != null && cell.value == null && cell.koho.has(hintNo),
            'color-selected':hintNo == null &&  cell.index == selectedCellIndex
          }"
          @touchend="tappable=true; cellTouched(cell, true)"
          @click="cellTouched(cell, false)">
          <!-- „Éû„Çπ„ÅÆ‰∏≠„ÅÆÊï∞Â≠ó -->
          <div class="masu-cell-number center-middle">
            {{cell.value}}
          </div>
          <!-- ÂÄôË£úË°®Á§∫Áî®3x3„Éû„Çπ -->
          <div class="masu3x3 masu-cell-koho center-middle"
            v-for="n in numbers"
            v-bind:class="{
              'color-koho': cell.koho.has(n),
              'color-reached-koho': cell.koho.has(cell.reachedNo) && n == cell.reachedNo && reachedKohoVisible,
              'hidden': cell.koho.size == 9
            }">
            {{cell.koho.has(n) ? n : null}}
          </div>
        </div>
      </div>
    </div>
    <div class="bottom-container">
      <input class="bottom-button hint-button" type="button"
        value="„Éí„É≥„Éà"
        @touchstart="hintTouched(true, true)"
        @touchend="tappable=true; hintTouched(false, true)"
        @mousedown="hintTouched(true, false)"
        @mouseup="hintTouched(false, false)">
      <div class="stepcount-text">{{stepCount}}ÊâãÁõÆ</div>
      <input class="bottom-button" type="button" value="‰∏ÄÊâãÊàª„Çã" @click="undo()">
    </div>
    <!-- „Ç≠„Éº„Éë„ÉÉ„Éâ -->
    <div class="keypad-container">
      <input type="button" class="keypad-button-number center-middle"
        v-for="no in numbers"
        :value="no"
        :disabled="!inputCell || (!inputCell.value && !inputCell.koho.has(no))"
        @click="inputButtonClicked(no)"
        @touchstart="inputButtonPress(no)"
        @touchend="inputButtonRelease(no)">
      <div></div>
      <input type="button" class="keypad-button-delete"
        value="ÂâäÈô§"
        :disabled="!inputCell || !inputCell.value"
        @click="inputButtonClicked(null)">
      <div></div>
    </div>
  </main>

  <transition name="popup">
    <div class="popup-fill" v-if="isFinished" @click="closeInputPopup">
      <div class="popup-window" tabindex="0" ref="popupWindow" @click="dummy">
        <div class="title-reward">
          üéçüéâüéä„Çà„Åè„Åß„Åç„Åæ„Åó„ÅüüíÆüëèüåª
        </div>
        <div class="popup-close-box" @click="closeInputPopup">
          <div class="popup-close">‚úñ</div>
        </div>
      </div>
    </div>
  </transition>
</div>

<script>
  const app = new Vue({
    el: "#app",
    data: {
      cells: [],
      blocks: [],
      numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9],
      selectedCellIndex: null,
      inputCell: null,
      tappable: false,
      undoStack: [],
      stepCount: 0,
      hintCount: 0,
      reachedKohoVisible: false,
      longPressTimeout: null,
      hintNo: null,
    },
    created() {
      this.cells = Array(9 * 9).fill().map((_, idx) => {
        return {
          index: idx,
          value: null,
          koho: new Set(this.numbers),
          reachedNo: 0
        };
      });
      this.blocks = new Array(9).fill().map((_) => { return [] });
      this.cells.forEach((cell, idx) => {
        // +----------------------------+
        // | 0| 1| 2|| 3| 4| 5|| 6| 7| 8|
        // +----------------------------+
        // | 9|10|11||  |  |  ||  |  |  |
        // +----------------------------+
        this.blocks[Math.floor(idx / 3) % 3 + Math.floor(idx / (9 * 3)) * 3].push(cell);
      });
    },
    mounted() {
      document.addEventListener("keydown", this.keydown);
    },
    computed: {
      isFinished() {
        return this.cells.every((cell) => cell.value);
      }
    },
    methods: {
      cellTouched(cell, byTap) {
        if (cell.reachedNo) {
          // „É™„Éº„ÉÅ„Åó„Å¶„Çã„Éû„Çπ„ÇíÁ¢∫ÂÆö
          this.setCellValue(cell, cell.reachedNo);
        }

        if (byTap == this.tappable) {
          if (this.selectedCellIndex === cell.index) {
            this.inputCell = null;
            this.selectedCellIndex = null;
          } else {
            this.inputCell = cell;
            this.selectedCellIndex = cell.index;
          }
        }
      },
      setCellValue(cell, no) {
        this.undoStack.push({
          index: cell.index,
          value: cell.value
        });
        cell.value = no;
        updateKoho(this.cells);
        this.stepCount += 1;
      },
      keydown(e) {
        const cell = (this.selectedCellIndex !== null) ? this.cells[this.selectedCellIndex] : null;
        if (cell && "1" <= e.key && e.key <= "9") {
          // Êï∞Â≠óË®≠ÂÆö
          const no = parseInt(e.key);
          let allow = false;
          if (cell.value) {
            if (inspectCells(this.cells, cell.index, no)) {
              allow = true;
            }
          } else {
            if (cell.koho.has(no)) {
              allow = true;
            }
          }

          if (allow) {
            this.setCellValue(cell, no);
          } else {
            this.flashSelection();
          }
        } else if (e.key.startsWith("Arrow")) {
          // ÈÅ∏Êäû„Éû„ÇπÁßªÂãï
          if (this.selectedCellIndex !== null) {
            if (e.key == "ArrowLeft") {
              this.selectedCellIndex += (this.selectedCellIndex % 9 == 0) ? +8 : -1;
            } else if (e.key == "ArrowRight") {
              this.selectedCellIndex += (this.selectedCellIndex % 9 == 8) ? -8 : +1;
            } else if (e.key == "ArrowUp") {
              this.selectedCellIndex += (Math.floor(this.selectedCellIndex / 9) == 0) ? +(8 * 9) : -9;
            } else if (e.key == "ArrowDown") {
              this.selectedCellIndex += (Math.floor(this.selectedCellIndex / 9) == 8) ? -(8 * 9) : +9;
            } else {
            }
          } else {
            this.selectedCellIndex = 40;
          }
        } else if (cell && e.key == "Delete") {
          // Êï∞Â≠óÂâäÈô§
          if (cell.value) {
            this.setCellValue(cell, null);
          }
        } else if (e.key == "Escape") {
          this.selectedCellIndex = null;
        } else if (e.key == "u") {
          this.undo();
        } else {
        }
      },
      undo() {
        if (0 < this.undoStack.length) {
          const undo = this.undoStack.pop();
          this.cells[undo.index].value = undo.value;
          if (this.selectedCellIndex) {
            this.selectedCellIndex = undo.index;
          }
          updateKoho(this.cells);
          this.stepCount -= 1;
        }
      },
      hintTouched(visible, byTap) {
        if (byTap) {
          this.tappable = true;
        }

        if (byTap == this.tappable) {
          if (!this.reachedKohoVisible && visible) {
            this.hintCount += 1;
          }
          this.reachedKohoVisible = visible;
        }
      },
      flashSelection() {
        // ÈÅ∏Êäû„Éû„Çπ„Çí„Éî„Ç´„ÉÉ„Å®
        const idx = this.selectedCellIndex;
        this.selectedCellIndex = null;
        setTimeout(() => this.selectedCellIndex = idx, 100);
      },
      dummy(e) {
          e.stopPropagation();
      },
      closeInputPopup() {
        this.inputCell = null;
      },
      inputButtonClicked(no) {
        if (this.inputCell) {
          this.setCellValue(this.inputCell, no);
        }
      },
      inputButtonPress(no) {
        if (this.longPressTimeout) {
          clearTimeout(this.longPressTimeout);
        }
        this.longPressTimeout = setTimeout(() => {
          this.hintNo = no;
          this.hintCount += 1;
        }, 500);
      },
      inputButtonRelease(no) {
        clearTimeout(this.longPressTimeout);
        this.longPressTimeout = null;
        this.hintNo = null;
      }
    }
  });

  function xyToIndex(x, y) {
    return (y * 9) + x;
  }

  function yxToIndex(y, x) {
    return xyToIndex(x, y);
  }

  function indexToX(idx) {
    return idx % 9;
  }

  function indexToY(idx) {
    return Math.floor(idx / 9);
  }

  function indexToBlock(idx) {
    const bx = Math.floor(idx / 3) % 3;
    const by = Math.floor(idx / (9 * 3));
    return (by * 3) + bx;
  }

  function blockToIndex(blockIndex, cellIndex) {
    const x = ((blockIndex % 3) * 3) + (cellIndex % 3);
    const y = Math.floor(blockIndex / 3) * 3  + Math.floor(cellIndex / 3) % 3;
    return (y * 9) + x;
  }

  // ÂÖ®„Çª„É´„ÅÆÂÄôË£ú„ÇíÊõ¥Êñ∞
  function updateKoho(cells) {

    for (let cell of cells) {
      cell.reachedNo = 0;
    }

    // ÂÄôË£úÊõ¥Êñ∞
    for (let y = 0; y < 9; ++y) {
      for (let x = 0; x < 9; ++x) {
        const cell = cells[xyToIndex(x, y)];
        cell.koho = getKohoSet(cells, cell.index);
        if (cell.koho.size == 1) {
          cell.reachedNo = cell.koho.values().next().value;
        }
      }
    }

    // „É¶„Éã„Éº„ÇØÂÄôË£úÁ¢∫Ë™ç
    for (let i = 0; i < 9; ++i) {
      for (let no = 1; no <= 9; ++no) {
        for (func of [xyToIndex, yxToIndex, blockToIndex]) {
          foundIndex = inspectReachedNo(cells, func, i, no);
          if (foundIndex !== null) {
            cells[foundIndex].reachedNo = no;
            break;
          }
        }
      }
    }
  }

  function inspectReachedNo(cells, indexFunc, idx, no) {
    let foundIndex = null;
    for (let i = 0; i < 9; ++i) {
      const cellIndex = indexFunc(idx, i);
      if (cells[cellIndex].koho.has(no)) {
        if (foundIndex !== null) {
          // ÂêåÂÄ§„ÅÇ„Çä
          return null;
        }
        foundIndex = cellIndex;
      }
    }
    return foundIndex;
  }

  // ÊåáÂÆö„Åó„Åü„Çª„É´„ÅÆÂÄôË£ú„ÇíÂèñÂæó
  function getKohoSet(cells, cellIndex) {
    const koho = [];
    const cell = cells[cellIndex];
    if (!cell.value) {
      for (let n = 1; n <= 9; ++n) {
        if (inspectCells(cells, cell.index, n)) {
          koho.push(n);
        }
      }
    }
    return new Set(koho);
  }

  // ‰ªÆ„Å´ÊåáÂÆö„ÅÆÂÄ§„ÇíÂÖ•„Çå„ÅüÂ†¥Âêà„Å´
  // „Åô„Åπ„Å¶„ÅÆË°å„ÉªÂàó„Éª„Éñ„É≠„ÉÉ„ÇØ„Å´ÈáçË§á„Åå„ÅÑ„Å™„ÅÑ„ÅãÁ¢∫Ë™ç
  // true:ÈáçË§á„Å™„Åó false:„ÅÇ„Çä
  function inspectCells(cells, cellIndex, tryValue) {
    const oldValue = cells[cellIndex].value;
    cells[cellIndex].value = tryValue;
    let result = true;
    if (
      !inspectUniqueness(cells, yxToIndex, indexToY(cellIndex)) ||
      !inspectUniqueness(cells, xyToIndex, indexToX(cellIndex)) ||
      !inspectUniqueness(cells, blockToIndex, indexToBlock(cellIndex))
    ) {
      result = false;
    }
    cells[cellIndex].value = oldValue;
    return result;
  }

  function inspectUniqueness(cells, indexFunc, idx) {
    const values = Array(9).fill().map((_, i) => cells[indexFunc(idx, i)].value);
    return !hasDuplicate(values);
  }

  function hasDuplicate(values) {
    const a = values.filter(v => v);
    const s = new Set(a);
    return s.size != a.length;
  }
</script>
</html>
